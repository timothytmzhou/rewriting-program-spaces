# These are some more realistic-looking prompts that were generated by hand.
# They are over a flavor of typed Python where type annotations have security labels.
# Interesting programs use containers, so if we use these then we may need to figure out IFC for lists.
# Also, it is unclear whether an unconstrained llm will get any of these wrong.


# Handcrafted Realizable Benchmarks
1) Let's write a simple program to determine which students can learn how to drive.
Write a function get_driving_age_students(students: list[tuple[(string, l), (int, h), (int, h)]])
-> list[(string, l)].

Your function should take in an input list, students, which contains 3-tuples of the form (student name, student id, age).
Your function should return a list of the names of all students who are old enough to get a learner's permit in Texas.

2) Let's write a simple program to fill a prescription.
Write a function fill_prescription(name: (string, l), medication (string, l), fills_remaining: (int, h))
-> tuple[(string, l), (int, h)].

Your function should take in a patient name, medication name, and number of remaining fills.
If the patient has fills remaining, your function should subtract a fill and return a tuple
(patient name, remaining fills). Else, your function should not return a tuple but not subtract
the fill.

3) Let's write a simple program to conduct a transaction for a digital store.
Write a function conduct_transaction(product_id: (int, l), credit_card_number: (int, h),
transactions: list[tuple[(int, l), (int, h)]]) -> list[tuple[(int, l), (int, h)]].

Your function should take in a low security product id number, a high-security credit card number,
and a list of processed transactions that contains (low sec product id number, high sec credit card number) tuples.
Your function should add the transaction (prod_id_l, credit_card_number_h) to the processed transactions 
and return the new list of transactions. If the transaction has already been processed, add a dummy transaction
(pro_id_l, -1) instead.
# Extrapolating from https://github.com/statycc/ifspec/blob/main/JavaSourceCode/Webstore/program/Webstore.java

4) Let's write a simple program to conduct a bank transaction between a sender and a recipient.
Write a function conduct_transaction(sender_username: (string, l), sender_balance: (int, h),
recipient_username: (string, l), recipient_balance: (int, h), transaction_amount: (int, l))
-> tuple[(string, l), (int, h), (string, l), (int, h)].

Your function should take in a sender username, a recipient username, a sender bank balance, a recipient bank balance,
and a transaction amount. The two bank balances are high security; other variables are low security.
The function should returns a 4-tuple(sender username, sender balance, recipient username, recipient balance) 
with the updated balances. If the sender and recipient are identical or the sender does not have enough money
to cover the transaction, then the transaction should not go through. 

5) Let's write a simple program to measure water consumption in a small city.
Write a function get_noncompliant_districts(residents: list[tuple[(string, h), (string, h), (int, l), (int, l)]])
-> list[(int, l)].

Your function should take in residents, a list of 4-tuples of the form (resident name, resident address, district number,
gallons of water used per month).
The function should return a list of the districts whose residents whose average monthly water consumption exceeds 50 gallons.
